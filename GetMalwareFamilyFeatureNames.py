import scipy.sparse
import numpy as np
import random
from sklearn.feature_extraction import DictVectorizer
from sklearn import svm
from collections import OrderedDict

import CommonModules as CM

def GetMalwareFamilyFeatureNames(MalwareCorpus, GoodwareCorpus, FeatureToSelect, C, FeatureDict, OutputFiles=""):
    '''
    This funtion is intended not to classify the sampls.
    Just the features are extracted and Clf is fit (C is variable).
    Then all features are ranked and dumped into o/p file.
    Expected inference - different top features for every family!
    '''
    # step 1: creating feature vector
    AllMalFeatureVectors = scipy.sparse.csr_matrix((1, len(FeatureDict)), dtype=bool)
    AllGoodFeatureVectores = scipy.sparse.csr_matrix((1, len(FeatureDict)), dtype=bool)
    # In order to use scipy.sparse.vstack, there will be one row with zeros appearing in both matrix, so it should not affect the results.
    # Modified. These two rows will be deleted after adding all vectors.

    random.seed(1)
    AllMalSamples = CM.ListFiles(MalwareCorpus, ".data")
    random.shuffle(AllMalSamples)
    MalSamplesTrainingSize = len(AllMalSamples)
    if MalSamplesTrainingSize < 30:
        return
    AllGoodSamples = CM.ListFiles(GoodwareCorpus, ".data")
    random.shuffle(AllGoodSamples)
    GoodSamplesTrainingSize = len(AllGoodSamples)
    # make sure GoodSamplesTrainingSize is always larger than MalSamplesTrainingSize
    SampleSize = min(MalSamplesTrainingSize, GoodSamplesTrainingSize)
    AllMalSamples = AllMalSamples[:SampleSize]
    AllGoodSamples = AllGoodSamples[:SampleSize]
    MalSamplesTrainingSize = SampleSize
    GoodSamplesTrainingSize = SampleSize
    print "Loaded samples"

    FeatureDictVectorizer = DictVectorizer(sort=False)  # Set sparse = False if necessary(Need to change the code below)
    FeatureDictVectorizer.fit_transform(FeatureDict)  # Cannot use fit.(Need to use "materializing" before fit)
    # print FeatureDictVectorizer.feature_names_
    for Sample in AllMalSamples:
        SampleData = CM.ImportFromJson(Sample)
        SampleData = CM.FlattenList(SampleData.values())
        SampleDataDict = OrderedDict()
        # No need to use SampleDataDict. Even if we use traditional dict, the feature vector transformed by Vectorizer
        # should also be in the correct order, because we set sort parameter of vectorizer to be False.
        SampleDataDict = {Value: 1 for Value in SampleData}
        FeatureVector = FeatureDictVectorizer.transform(SampleDataDict)
        # FeatureVectorList = FeatureVector.toarray().tolist()
        # FeatureVectorList = FeatureVector.tolist() if sparse = False
        # CM.ExportToJson(os.path.splitext(Sample)[0]+".fv", FeatureVectorList)
        AllMalFeatureVectors = scipy.sparse.vstack([AllMalFeatureVectors, FeatureVector])
        # Add a new row in sparse matrix.

    for Sample in AllGoodSamples:
        SampleData = CM.ImportFromJson(Sample)
        SampleData = CM.FlattenList(SampleData.values())
        SampleDataDict = OrderedDict()
        # for Value in SampleData:
        #    SampleDataDict[Value] = 1
        # print SampleDataDict
        # No need to use SampleDataDict. Even if we use traditional dict, the feature vector transformed by Vectorizer
        # should also be in the correct order, because we set sort parameter of vectorizer to be False.
        SampleDataDict = {Value: 1 for Value in SampleData}
        FeatureVector = FeatureDictVectorizer.transform(SampleDataDict)
        # print FeatureVector.__class__
        AllGoodFeatureVectores = scipy.sparse.vstack([AllGoodFeatureVectores, FeatureVector])
    CM.DeleteCsrMatrixRow(AllMalFeatureVectors, 0)
    CM.DeleteCsrMatrixRow(AllGoodFeatureVectores, 0)

    # step 2: split samples to training set and test set

    TrainMalSamples = AllMalFeatureVectors[:MalSamplesTrainingSize]
    TrainGoodSamples = AllGoodFeatureVectores[:GoodSamplesTrainingSize]
    # Test split will return sparse matrices if the arguments are sparse matrices.
    print "train-test split done"

    # label malware as 1 and goodware as -1
    TrainMalLabels = np.ones(TrainMalSamples.shape[0])
    TrainGoodLabels = np.empty(TrainGoodSamples.shape[0])
    TrainGoodLabels.fill(-1)

    TrainSamples = scipy.sparse.vstack([TrainMalSamples, TrainGoodSamples])

    TrainLabels = TrainMalLabels.tolist()
    TrainLabels.extend(TrainGoodLabels.tolist())
    print "Labels array - generated"

    # step 3: model selection
    print "performing CV"

    if -1 == FeatureToSelect:
        FeatureToSelect = len(FeatureDict) - 1
    else:
        FeatureToSelect = min(len(FeatureDict) - 1, FeatureToSelect)
    # Clf = svm.LinearSVC(C = 1, penalty="l2", class_weight = "auto").fit(TrainSamples, TrainLabels)
    Clf = svm.LinearSVC(C=C, penalty="l2").fit(TrainSamples, TrainLabels)
    FeautureImportances = Clf.coef_[0]
    TopFeatureIndices = FeautureImportances.argsort()[-FeatureToSelect:][::-1]
    # print TopFeatureIndices[:100]
    FeatureList = FeatureDictVectorizer.feature_names_

    '''
    Noe calculating the likelihood of a feature in a mal/good samples pair
    '''
    MalApkCountDict = {}
    for FeatureIndex in TopFeatureIndices:
        MalApkCountDict[FeatureIndex] = 0
    TotalMalApkCount = TrainMalSamples.shape[0]
    for Sample in range(TrainMalSamples.shape[0]):
        SampleVector = TrainMalSamples[Sample, :].toarray()
        # print SampleVector
        for FeatureIndex in TopFeatureIndices:
            if SampleVector[0, FeatureIndex] == 1:
                MalApkCountDict[FeatureIndex] = MalApkCountDict[FeatureIndex] + 1

    GoodApkCountDict = {}
    for FeatureIndex in TopFeatureIndices:
        GoodApkCountDict[FeatureIndex] = 0
    TotalGoodApkCount = TrainGoodSamples.shape[0]
    for Sample in range(TrainGoodSamples.shape[0]):
        SampleVector = TrainGoodSamples[Sample, :].toarray()
        # print SampleVector
        for FeatureIndex in TopFeatureIndices:
            if SampleVector[0, FeatureIndex] == 1:
                GoodApkCountDict[FeatureIndex] = GoodApkCountDict[FeatureIndex] + 1

                # step 4: print FeautureImportances
    if OutputFiles == "":
        for FIndex in TopFeatureIndices:
            print FeatureList[FIndex], FeautureImportances[FIndex], MalApkCountDict[FIndex],
            TotalMalApkCount, MalApkCountDict[FIndex] / TotalMalApkCount, GoodApkCountDict[FIndex],
            TotalGoodApkCount, GoodApkCountDict[FIndex] / TotalGoodApkCount
    else:
        f = open(OutputFiles, "a");
        f.write("Malware Family: " + MalwareCorpus + "\n")
        for FIndex in TopFeatureIndices:
            f.write(FeatureList[FIndex] + " " + str(FeautureImportances[FIndex]) +
                    " " + str(MalApkCountDict[FIndex]) + "/" + str(TotalMalApkCount) + " " +
                    str(MalApkCountDict[FIndex] / float(TotalMalApkCount)) +
                    " " + str(GoodApkCountDict[FIndex]) + "/" + str(TotalGoodApkCount) + " " +
                    str(GoodApkCountDict[FIndex] / float(TotalGoodApkCount)) + "\n")
        f.write("\n")
        f.close()
    print 'pls check teh CWD FeatureNamesAndImportance.txt file for the features/wts'